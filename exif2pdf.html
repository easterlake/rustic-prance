<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON/EXIF Viewer</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- External libraries for local file processing and reporting -->
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.19.0/js/md5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Highlight.js for code formatting, although the custom tree viewer is now used for JSON -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/idea.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
    <style>
        /* Custom styles for Inter font and general aesthetics */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to the top */
            min-height: 100vh;
            margin: 0;
            padding: 2rem; /* Add padding for better spacing */
        }
        .container {
            background-color: #ffffff;
            padding: 2.5rem;
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 48rem;
            display: flex;
            flex-direction: column;
            gap: 2rem; /* Increased space between sections */
        }
        input[type="text"] {
            padding: 0.75rem 1rem;
            border: 1px solid #d1d5db;
            border-radius: 0.75rem;
            font-size: 1rem;
            width: 100%;
            box-sizing: border-box;
            transition: border-color 0.2s ease-in-out;
        }
        input[type="text"]:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
        }
        button {
            background-color: #2563eb;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            border: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        button:hover {
            background-color: #1d4ed8;
            transform: translateY(-1px);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .content-display {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 0.75rem;
            padding: 1.25rem;
            min-height: 8rem;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            color: #374151;
            overflow-x: auto;
        }
        .error-message {
            color: #ef4444;
            font-weight: 500;
        }
        .loading-message {
            color: #4f46e5;
            font-weight: 500;
        }
        .summary-container, .explanation-container, .image-container {
            margin-top: 1.5rem;
            padding: 1rem;
            border-radius: 0.75rem;
            background-color: #e2e8f0;
            font-family: 'Inter', sans-serif;
            color: #1f2937;
        }
        .image-container img {
            max-width: 100%;
            height: auto;
            border-radius: 0.75rem;
            margin-top: 1rem;
        }
        .gemini-api-button {
            background-color: #a78bfa;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .gemini-api-button:hover {
            background-color: #8b5cf6;
        }
        /* Styles for local file thumbnail and download buttons */
        .thumbnail-container {
            margin-bottom: 1rem;
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            background: #fff;
        }
        .thumbnail {
            width: 100%;
            height: auto;
            display: block;
            object-fit: contain;
            background: #fff;
            padding: 1rem;
        }
        .export-buttons button {
            background-color: #268bd2;
            color: #fff;
            padding: 0.5em 1em;
            font-size: 1em;
            border-radius: 0.5rem;
        }
        .export-buttons button:hover {
            background: #155ab6;
        }
        /* JSON Tree View Specific Styles */
        .json-tree ul {
            list-style-type: none;
            padding-left: 1.5em;
            margin: 0;
        }
        .json-tree li {
            position: relative;
            line-height: 1.5;
        }
        .json-tree .key {
            color: #881a88;
            font-weight: bold;
            margin-right: 0.5em;
        }
        .json-tree .string {
            color: #008000;
        }
        .json-tree .number {
            color: #1a0dab;
        }
        .json-tree .boolean {
            color: #0000ff;
        }
        .json-tree .null {
            color: #808080;
        }
        .json-tree .collapsible {
            cursor: pointer;
        }
        .json-tree .collapsible::before {
            content: '►';
            display: inline-block;
            width: 1em;
            margin-right: 0.2em;
            transition: transform 0.1s ease-in-out;
        }
        .json-tree .collapsible.expanded::before {
            content: '▼';
            transform: rotate(0deg);
        }
        .json-tree .collapsible-content {
            display: none;
        }
        .json-tree .collapsible.expanded + .collapsible-content {
            display: block;
        }
        .json-tree .array-length, .json-tree .object-keys {
            color: #808080;
            font-size: 0.8em;
            margin-left: 0.5em;
        }
        .collapsible-string-wrapper {
            display: inline-flex;
            align-items: flex-start;
        }
        .collapsible-string-toggle {
            cursor: pointer;
            display: flex;
            align-items: center;
            color: #008000;
        }
        .collapsible-string-toggle .toggle-arrow {
            content: '►';
            display: inline-block;
            width: 1em;
            margin-right: 0.2em;
            transition: transform 0.1s ease-in-out;
        }
        .collapsible-string-toggle.expanded .toggle-arrow {
            content: '▼';
            transform: rotate(0deg);
        }
        .truncated-text {
            font-style: italic;
            color: #808080;
        }
        .full-string-content {
            display: none;
            margin-left: 1.5em;
            word-break: break-all;
            white-space: pre-wrap;
        }
        .full-string-content.expanded {
            display: block;
        }
        .explain-key-button {
            cursor: pointer;
            color: #a78bfa;
            font-size: 1.25rem;
            margin-left: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">JSON & EXIF Data Viewer</h1>

        <!-- Input methods section -->
        <div class="flex flex-col md:flex-row gap-6">
            <!-- Fetch by Object ID -->
            <div class="flex-1 p-6 bg-gray-50 border border-gray-200 rounded-xl flex flex-col gap-4">
                <label for="objectId" class="text-gray-700 text-lg font-medium">1. Fetch by Object ID:</label>
                <input type="text" id="objectId" placeholder="e.g., 12345">
                <button onclick="fetchAndDisplayContent()">Fetch & Display</button>
            </div>
            
            <!-- Or selector -->
            <div class="relative flex-none hidden md:flex items-center justify-center text-gray-400">
                <span class="absolute px-2 bg-white text-sm">OR</span>
                <div class="absolute w-full h-px bg-gray-300 -z-10"></div>
            </div>

            <!-- Select Local File -->
            <div class="flex-1 p-6 bg-gray-50 border border-gray-200 rounded-xl flex flex-col gap-4">
                <label for="fileInput" class="text-gray-700 text-lg font-medium">2. Select an image file:</label>
                <input type="file" id="fileInput" accept="image/*">
            </div>
        </div>

        <!-- Display section -->
        <div id="resultsSection" class="hidden">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Results</h2>

            <!-- Local file thumbnail display -->
            <div id="thumbnailDisplay" class="thumbnail-container hidden">
                <img id="thumbnail" class="thumbnail" alt="Image Thumbnail Preview">
                <p id="thumbnote" class="note text-sm text-gray-500 text-center"></p>
            </div>

            <!-- Report download buttons from user's code -->
            <div id="exportButtons" class="mt-4 flex flex-wrap gap-2">
                <button id="downloadPdf" style="display:none;">Download PDF</button>
                <button id="downloadCsv" style="display:none;">Download CSV</button>
                <button id="downloadTxt" style="display:none;">Download TXT</button>
                <button id="downloadJson" style="display:none;">Download JSON</button>
                <button id="downloadZip" style="display:none;">Download ZIP</button>
            </div>

            <!-- Gemini API features buttons -->
            <div id="geminiApiButtons" class="mt-4 flex flex-wrap gap-2">
                <button id="summarizeButton" class="gemini-api-button" disabled onclick="summarizeJson()">Summarize JSON ✨</button>
                <button id="generateImageButton" class="gemini-api-button" disabled onclick="generateImageFromExif()">Generate Image from EXIF ✨</button>
            </div>

            <!-- File Info, MD5, and EXIF sections -->
            <div id="fileInfoSection" class="mt-6">
                <h3 class="text-xl font-semibold text-gray-700 mb-2">File Info</h3>
                <div id="fileInfo" class="content-display"></div>
            </div>
            
            <div id="md5Section" class="mt-6">
                <h3 class="text-xl font-semibold text-gray-700 mb-2">MD5 Hash</h3>
                <div id="md5" class="content-display"></div>
            </div>

            <div id="exifSection" class="mt-6">
                <h3 class="text-xl font-semibold text-gray-700 mb-2">EXIF Data</h3>
                <div id="exifContent" class="content-display">
                    <p class="text-gray-500">EXIF data will be displayed here.</p>
                </div>
            </div>
        </div>

        <!-- Gemini API output containers -->
        <div id="summaryContainer" class="summary-container hidden"></div>
        <div id="explanationContainer" class="explanation-container hidden"></div>
        <div id="imageContainer" class="image-container hidden"></div>
    </div>

    <script>
        // Define the base URL for your API endpoint
        const BASE_API_URL = 'https://web-imiusi338c8b.up-de-fra1-k8s-1.apps.run-on-seenode.com/get-exif';
        let currentData = null; // Variable to hold the fetched JSON data
        let state = { // Unified state object for file info and EXIF data
            file: null,
            fileInfo: '',
            md5: '',
            exif: {},
            thumbnailDataUrl: '',
            thumbnailType: '', // 'exif' or 'full'
            fileName: 'image'
        };

        const API_KEY = ""; // Gemini API key
        
        /**
         * Retries a fetch request with exponential backoff.
         * @param {string} url - The URL to fetch.
         * @param {object} options - Fetch options.
         * @param {number} retries - Number of retries left.
         */
        async function fetchWithBackoff(url, options, retries = 5) {
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response;
            } catch (error) {
                if (retries > 0) {
                    const delay = Math.pow(2, 5 - retries) * 1000;
                    console.warn(`Retrying in ${delay / 1000}s...`);
                    await new Promise(res => setTimeout(res, delay));
                    return fetchWithBackoff(url, options, retries - 1);
                } else {
                    throw error;
                }
            }
        }

        /**
         * Converts basic Markdown to HTML.
         * @param {string} markdownText - The text with Markdown to format.
         * @returns {string} The HTML string.
         */
        function formatMarkdown(markdownText) {
            // Convert newlines to <br> for proper line breaks
            let html = markdownText.replace(/\n/g, '<br>');
            // Bold (**text**)
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            // Italic (*text*)
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
            return html;
        }

        /**
         * Fetches JSON content from the constructed URL using the Object ID and displays it.
         */
        async function fetchAndDisplayContent() {
            const objectIdInput = document.getElementById('objectId');
            const contentDisplay = document.getElementById('exifContent');
            const objectId = objectIdInput.value.trim();

            // Clear previous results and show loading state
            resetDisplay();

            if (!objectId) {
                contentDisplay.innerHTML = '<p class="error-message">Please enter an Object ID.</p>';
                return;
            }

            contentDisplay.innerHTML = '<p class="loading-message">Fetching data...</p>';

            const targetUrl = `${BASE_API_URL}/${encodeURIComponent(objectId)}`;
            const proxyUrl = 'https://corsproxy.io/?';
            const finalUrl = proxyUrl + encodeURIComponent(targetUrl);

            try {
                const response = await fetch(finalUrl);
                if (!response.ok) {
                    contentDisplay.innerHTML = `<p class="error-message">HTTP error! Status: ${response.status} - ${response.statusText}. It might be a CORS issue or the Object ID is invalid.</p>`;
                    return;
                }
                const data = await response.json();
                state.exif = data;
                state.fileInfo = `Fetched from API\nObject ID: ${objectId}\nType: application/json`;
                state.md5 = 'N/A';
                state.thumbnailDataUrl = ''; // No thumbnail from API
                state.fileName = `object_${objectId}`;

                displayContent();
                
            } catch (error) {
                contentDisplay.innerHTML = `<p class="error-message">Error fetching or parsing JSON: ${error.message}. This often happens due to network issues or Cross-Origin Resource Sharing (CORS) restrictions.</p>`;
                console.error("Fetch or JSON parsing error:", error);
                
            }
        }
        
        /**
         * Generates a summary of the current JSON data using the Gemini API.
         */
        async function summarizeJson() {
            const summaryContainer = document.getElementById('summaryContainer');
            summaryContainer.classList.remove('hidden');
            summaryContainer.innerHTML = '<p class="loading-message">Generating summary...</p>';

            try {
                const prompt = `Summarize the following EXIF data in a human-readable format. Highlight key details like camera make, model, lens, exposure settings (ISO, aperture, shutter speed), and date taken:\n\n${JSON.stringify(currentData, null, 2)}`;
                let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = { contents: chatHistory };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;
                const response = await fetchWithBackoff(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                const summary = result?.candidates?.[0]?.content?.parts?.[0]?.text || "Failed to generate summary.";

                summaryContainer.innerHTML = `
                    <h3 class="text-xl font-bold mb-2">Summary ✨</h3>
                    <p>${formatMarkdown(summary)}</p>
                `;
            } catch (error) {
                summaryContainer.innerHTML = `<p class="error-message">Error generating summary: ${error.message}</p>`;
                console.error("Gemini API error:", error);
            }
        }

        /**
         * Explains a specific JSON key and its value using the Gemini API.
         * @param {string} key - The key to explain.
         * @param {any} value - The value of the key.
         */
        async function explainJsonKey(key, value) {
            const explanationContainer = document.getElementById('explanationContainer');
            explanationContainer.classList.remove('hidden');
            explanationContainer.innerHTML = `<p class="loading-message">Explaining key "${key}"...</p>`;

            try {
                const prompt = `Explain what the EXIF key "${key}" means. If possible, provide context based on its value: "${JSON.stringify(value)}". Keep the explanation concise and easy to understand.`;
                let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = { contents: chatHistory };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;
                const response = await fetchWithBackoff(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();
                const explanation = result?.candidates?.[0]?.content?.parts?.[0]?.text || "Failed to get an explanation.";

                explanationContainer.innerHTML = `
                    <h3 class="text-xl font-bold mb-2">Explanation for "${key}" ✨</h3>
                    <p>${formatMarkdown(explanation)}</p>
                `;
            } catch (error) {
                explanationContainer.innerHTML = `<p class="error-message">Error explaining key: ${error.message}</p>`;
                console.error("Gemini API error:", error);
            }
        }
        
        /**
         * Generates an image using the Gemini API based on the EXIF data.
         */
        async function generateImageFromExif() {
            const imageContainer = document.getElementById('imageContainer');
            imageContainer.classList.remove('hidden');
            imageContainer.innerHTML = '<p class="loading-message">Generating image from EXIF data... Please wait a moment.</p>';

            try {
                const promptFromExif = `Generate an image based on the following photo metadata:\n\n` +
                    (currentData.Make ? `Camera Make: ${currentData.Make}\n` : '') +
                    (currentData.Model ? `Camera Model: ${currentData.Model}\n` : '') +
                    (currentData.LensModel ? `Lens Model: ${currentData.LensModel}\n` : '') +
                    (currentData.DateTimeOriginal ? `Date Taken: ${currentData.DateTimeOriginal}\n` : '') +
                    (currentData.ShutterSpeedValue ? `Shutter Speed: ${currentData.ShutterSpeedValue}\n` : '') +
                    (currentData.ApertureValue ? `Aperture: f/${currentData.ApertureValue}\n` : '') +
                    (currentData.ISO ? `ISO: ${currentData.ISO}\n` : '') +
                    (currentData.ExposureProgram ? `Exposure Program: ${currentData.ExposureProgram}\n` : '') +
                    `Describe a scene that might be captured with these settings and generate an image of it.`;
                
                const payload = { 
                    instances: { prompt: promptFromExif },
                    parameters: { "sampleCount": 1}
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${API_KEY}`;
                
                const response = await fetchWithBackoff(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                const base64Data = result?.predictions?.[0]?.bytesBase64Encoded;

                if (!base64Data) {
                    imageContainer.innerHTML = `<p class="error-message">Failed to generate image. The API response was not in the expected format.</p>`;
                    return;
                }

                const imageUrl = `data:image/png;base64,${base64Data}`;
                imageContainer.innerHTML = `
                    <h3 class="text-xl font-bold mb-2">Generated Image ✨</h3>
                    <img src="${imageUrl}" alt="Generated from EXIF data">
                `;

            } catch (error) {
                imageContainer.innerHTML = `<p class="error-message">Error generating image: ${error.message}</p>`;
                console.error("Image Generation API error:", error);
            }
        }

        /**
         * Recursively renders JSON data into an expandable/collapsible HTML tree.
         * @param {any} data - The JSON data to render.
         * @param {string} keyName - The key name for the current data (used for display).
         * @returns {string} The HTML string representation of the JSON data.
         */
        function renderJsonTree(data, keyName = null) {
            let html = '';

            if (data === null) {
                html += `<li><span class="key">${keyName ? JSON.stringify(keyName) + ': ' : ''}</span><span class="null">null</span></li>`;
            } else if (typeof data === 'object') {
                const isArray = Array.isArray(data);
                const count = isArray ? data.length : Object.keys(data).length;
                const contentId = `json-content-${Math.random().toString(36).substring(2, 9)}`;

                html += `<li>`;
                html += `<span class="collapsible" onclick="toggleCollapse('${contentId}', this)">`;
                html += `<span class="key">${keyName ? JSON.stringify(keyName) + ': ' : ''}</span>`;
                html += `<span class="type-indicator">${isArray ? '[' : '{'}</span>`;
                html += `<span class="${isArray ? 'array-length' : 'object-keys'}">${count} ${isArray ? 'items' : 'keys'}</span>`;
                html += `<span class="type-indicator">${isArray ? ']' : '}'}</span>`;
                html += `</span>`; // End collapsible span

                html += `<ul id="${contentId}" class="collapsible-content">`;
                if (isArray) {
                    data.forEach((item, index) => {
                        html += renderJsonTree(item, index);
                    });
                } else {
                    for (const key in data) {
                        if (Object.prototype.hasOwnProperty.call(data, key)) {
                            html += renderJsonTree(data[key], key);
                        }
                    }
                }
                html += `</ul>`;
                html += `</li>`;
            } else {
                let valueClass = '';
                let displayValue = JSON.stringify(data);

                if (typeof data === 'string') {
                    valueClass = 'string';
                    // Special handling for MakerNote string
                    if (keyName === 'MakerNote' && data.includes('\u0000')) {
                        const uniqueId = `makernote-content-${Math.random().toString(36).substring(2, 9)}`;
                        html += `<li><span class="key">${JSON.stringify(keyName)}: </span>`;
                        html += `<span class="collapsible-string-wrapper">`;
                        html += `<span class="collapsible-string-toggle" onclick="toggleStringCollapse('${uniqueId}', this)">`;
                        html += `<span class="toggle-arrow">►</span>`;
                        html += `<span class="truncated-text">[...binary MakerNote data...]</span>`;
                        html += `</span>`;
                        html += `<div id="${uniqueId}" class="full-string-content">`;
                        html += `<span class="string">${displayValue}</span>`;
                        html += `</div>`;
                        html += `</span></li>`;
                        return html;
                    }
                } else if (typeof data === 'number') {
                    valueClass = 'number';
                } else if (typeof data === 'boolean') {
                    valueClass = 'boolean';
                }

                html += `<li>
                    <span class="key">${keyName ? JSON.stringify(keyName) + ': ' : ''}</span>
                    <span class="${valueClass}">${displayValue}</span>
                    <span class="explain-key-button" onclick="explainJsonKey('${keyName}', '${data}')">✨</span>
                </li>`;
            }

            return html;
        }

        /**
         * Toggles the visibility of collapsible JSON content (for objects/arrays).
         * @param {string} contentId - The ID of the content element to toggle.
         * @param {HTMLElement} triggerElement - The element that was clicked (e.g., the span with the arrow).
         */
        function toggleCollapse(contentId, triggerElement) {
            const contentElement = document.getElementById(contentId);
            if (contentElement) {
                contentElement.classList.toggle('expanded');
                triggerElement.classList.toggle('expanded');
            }
        }

        /**
         * Toggles the visibility of a collapsible string (e.g., MakerNote).
         * @param {string} contentId - The ID of the full string content element.
         * @param {HTMLElement} triggerElement - The element that was clicked (the toggle span).
         */
        function toggleStringCollapse(contentId, triggerElement) {
            const contentElement = document.getElementById(contentId);
            if (contentElement) {
                contentElement.classList.toggle('expanded');
                triggerElement.classList.toggle('expanded');
            }
        }

        // --- Local File Processing Functions from user's code, adapted for this app ---

        /**
         * Converts an EXIF thumbnail (binary) to a data URL.
         */
        function exifThumbnailToDataURL(exifObj) {
            if (exifObj && exifObj['Thumbnail']) {
                let thumb = exifObj['Thumbnail'];
                let binary = '';
                if (thumb instanceof Uint8Array) {
                    binary = String.fromCharCode.apply(null, thumb);
                } else if (thumb instanceof ArrayBuffer) {
                    binary = String.fromCharCode.apply(null, new Uint8Array(thumb));
                } else if (typeof thumb === 'string') {
                    binary = thumb;
                }
                if (binary.length > 0) {
                    return 'data:image/jpeg;base64,' + btoa(binary);
                }
            }
            return null;
        }

        /**
         * Upscales an EXIF thumbnail for better display.
         */
        function upscaleThumbnail(dataUrl, targetWidth = 600, targetHeight = 600) {
            return new Promise(resolve => {
                const img = new window.Image();
                img.onload = function() {
                    let scale = Math.min(targetWidth / img.width, targetHeight / img.height, 1);
                    let w = Math.round(img.width * scale);
                    let h = Math.round(img.height * scale);
                    const canvas = document.createElement('canvas');
                    canvas.width = w;
                    canvas.height = h;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, w, h);
                    resolve(canvas.toDataURL('image/jpeg'));
                };
                img.onerror = function() { resolve(dataUrl); };
                img.src = dataUrl;
            });
        }
        
        /**
         * Reads a file asynchronously.
         */
        function readFileAsync(file, type = 'DataURL') {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = reject;
                if (type === 'ArrayBuffer') reader.readAsArrayBuffer(file);
                else reader.readAsDataURL(file);
            });
        }

        /**
         * Computes the MD5 hash of a file.
         */
        async function computeMD5(file) {
            const arrayBuffer = await readFileAsync(file, 'ArrayBuffer');
            let binary = '';
            const bytes = new Uint8Array(arrayBuffer);
            for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
            return md5(binary);
        }

        /**
         * Extracts EXIF data and thumbnail from an image data URL.
         */
        async function extractExifAndThumbnail(dataUrl) {
            return new Promise(resolve => {
                const img = new Image();
                img.onload = function() {
                    EXIF.getData(img, function() {
                        const exif = EXIF.getAllTags(this);
                        let exifThumbUrl = exifThumbnailToDataURL(exif);
                        resolve({ exif, exifThumbUrl });
                    });
                };
                img.onerror = function() { resolve({ exif: {}, exifThumbUrl: null }); };
                img.src = dataUrl;
            });
        }

        /**
         * Converts an image to a canvas data URL with specified dimensions.
         */
        function imageToCanvasDataUrl(imgDataUrl, maxW = 600, maxH = 600) {
            return new Promise(resolve => {
                const img = new window.Image();
                img.onload = function() {
                    let scale = Math.min(maxW / img.width, maxH / img.height, 1);
                    let w = Math.round(img.width * scale);
                    let h = Math.round(img.height * scale);
                    const canvas = document.createElement('canvas');
                    canvas.width = w;
                    canvas.height = h;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, w, h);
                    resolve({ dataUrl: canvas.toDataURL('image/jpeg'), width: w, height: h });
                };
                img.onerror = function() { resolve({ dataUrl: imgDataUrl, width: 0, height: 0 }); };
                img.src = imgDataUrl;
            });
        }

        /**
         * Main function to handle file input change.
         */
        document.getElementById('fileInput').addEventListener('change', async function(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Clear previous results and show loading state
            resetDisplay();
            document.getElementById('exifContent').innerHTML = '<p class="loading-message">Reading local file...</p>';

            try {
                state.file = file;
                state.fileName = file.name ? file.name.replace(/\.[^/.]+$/, "") : 'image';
                state.fileInfo = `Name: ${file.name}\nSize: ${file.size} bytes\nType: ${file.type}`;
                state.md5 = await computeMD5(file);

                const dataUrl = await readFileAsync(file, 'DataURL');
                const { exif, exifThumbUrl } = await extractExifAndThumbnail(dataUrl);
                state.exif = exif;

                if (exifThumbUrl) {
                    state.thumbnailType = 'exif';
                    state.thumbnailDataUrl = await upscaleThumbnail(exifThumbUrl, 600, 600);
                } else {
                    state.thumbnailType = 'full';
                    state.thumbnailDataUrl = dataUrl;
                }

                displayContent();
                
            } catch (error) {
                document.getElementById('exifContent').innerHTML = `<p class="error-message">Error processing file: ${error.message}</p>`;
                console.error("File processing error:", error);
            }
        });

        /**
         * Updates the display with the data from the 'state' object.
         */
        function displayContent() {
            document.getElementById('resultsSection').classList.remove('hidden');
            document.getElementById('fileInfo').textContent = state.fileInfo;
            document.getElementById('md5').textContent = state.md5;

            // Update the global `currentData` for the Gemini API functions
            currentData = state.exif;
            
            // Display the thumbnail if available
            const imgEl = document.getElementById('thumbnail');
            const thumbNote = document.getElementById('thumbnote');
            const thumbnailDisplay = document.getElementById('thumbnailDisplay');

            if (state.thumbnailDataUrl) {
                imgEl.src = state.thumbnailDataUrl;
                thumbnailDisplay.classList.remove('hidden');
                thumbNote.textContent = state.thumbnailType === 'exif'
                    ? "Embedded EXIF thumbnail shown (upscaled)."
                    : "No embedded EXIF thumbnail found; full image shown.";
            } else {
                thumbnailDisplay.classList.add('hidden');
            }

            // Render EXIF data in the tree viewer
            const exifContentDiv = document.getElementById('exifContent');
            const jsonTreeHtml = `<div class="json-tree"><ul>${renderJsonTree(state.exif)}</ul></div>`;
            exifContentDiv.innerHTML = jsonTreeHtml;

            // Enable all action buttons
            toggleButtons(true);
        }
        
        /**
         * Clears the display and hides results/messages.
         */
        function resetDisplay() {
            document.getElementById('resultsSection').classList.add('hidden');
            document.getElementById('thumbnailDisplay').classList.add('hidden');
            document.getElementById('fileInfo').textContent = '';
            document.getElementById('md5').textContent = '';
            document.getElementById('exifContent').innerHTML = '<p class="text-gray-500">EXIF data will be displayed here.</p>';
            document.getElementById('summaryContainer').classList.add('hidden');
            document.getElementById('explanationContainer').classList.add('hidden');
            document.getElementById('imageContainer').classList.add('hidden');
            toggleButtons(false);
        }

        /**
         * Enables or disables all action buttons.
         */
        function toggleButtons(enable) {
            document.getElementById('summarizeButton').disabled = !enable;
            document.getElementById('generateImageButton').disabled = !enable;
            document.getElementById('downloadPdf').style.display = enable ? 'inline-block' : 'none';
            document.getElementById('downloadCsv').style.display = enable ? 'inline-block' : 'none';
            document.getElementById('downloadTxt').style.display = enable ? 'inline-block' : 'none';
            document.getElementById('downloadJson').style.display = enable ? 'inline-block' : 'none';
            document.getElementById('downloadZip').style.display = enable ? 'inline-block' : 'none';
        }

        // --- PDF EXPORT from user's code ---
        async function generatePdfBlob() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ unit: 'mm', format: 'a4' });
            const pageWidth = 210;
            const pageHeight = 297;
            const margin = 10;
            let y = 20;
            const now = new Date();
            const dateStr = now.toLocaleString();
            doc.setFontSize(10);
            const domain = window.location.hostname || 'localhost';
            doc.text(`${domain} | ${state.fileName} | Generated: ${dateStr}`, margin, 10);
            doc.setFont("courier", "normal");
            doc.setFontSize(12);
            let imgData = null, imgW = 0, imgH = 0;
            if (state.thumbnailDataUrl) {
                const imgCanvasData = await imageToCanvasDataUrl(state.thumbnailDataUrl, pageWidth - 2 * margin, 100);
                imgData = imgCanvasData.dataUrl;
                imgW = imgCanvasData.width;
                imgH = imgCanvasData.height;
                if (imgData && imgW && imgH) {
                    doc.text("Thumbnail:", margin, y);
                    y += 5;
                    doc.addImage(imgData, 'JPEG', margin, y, imgW, imgH);
                    y += imgH + 5;
                }
            }
            doc.text("File Info:", margin, y);
            y += 7;
            doc.setFontSize(10);
            state.fileInfo.split('\n').forEach(line => {
                doc.text(line, margin + 2, y);
                y += 5;
            });
            doc.setFontSize(12);
            y += 5;
            doc.text("MD5 Hash:", margin, y);
            y += 7;
            doc.text(state.md5, margin + 2, y);
            y += 10;
            const maxLineWidth = pageWidth - margin * 2;
            doc.text("EXIF Data:", margin, y);
            y += 7;
            const exifStr = JSON.stringify(state.exif, null, 2);
            let inMakerNote = false;
            let makerNoteBuffer = '';
            exifStr.split('\n').forEach(line => {
                if (!inMakerNote && line.trim().startsWith('"MakerNote":')) {
                    inMakerNote = true;
                    makerNoteBuffer = line.trim();
                    return;
                }
                if (inMakerNote) {
                    makerNoteBuffer += ' ' + line.trim();
                    if (line.trim().endsWith('"') || line.trim().endsWith('",')) {
                        const wrappedLines = doc.splitTextToSize(makerNoteBuffer, maxLineWidth);
                        wrappedLines.forEach(wrappedLine => {
                            if (y > pageHeight - 20) {
                                doc.addPage();
                                y = 20;
                                doc.setFontSize(10);
                                doc.text(`${domain} | ${state.fileName} | Generated: ${dateStr}`, margin, 10);
                                doc.setFontSize(12);
                                doc.text("EXIF Data (cont'd):", margin, y);
                                y += 7;
                            }
                            doc.text(wrappedLine, margin + 2, y);
                            y += 6;
                        });
                        inMakerNote = false;
                        makerNoteBuffer = '';
                    }
                    return;
                }
                const wrappedLines = doc.splitTextToSize(line, maxLineWidth);
                wrappedLines.forEach(wrappedLine => {
                    if (y > pageHeight - 20) {
                        doc.addPage();
                        y = 20;
                        doc.setFontSize(10);
                        doc.text(`${domain} | ${state.fileName} | Generated: ${dateStr}`, margin, 10);
                        doc.setFontSize(12);
                        doc.text("EXIF Data (cont'd):", margin, y);
                        y += 7;
                    }
                    doc.text(wrappedLine, margin + 2, y);
                    y += 6;
                });
            });
            const pageCount = doc.internal.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFontSize(10);
                doc.text(
                    `Page ${i} of ${pageCount}`,
                    pageWidth - margin,
                    pageHeight - 7,
                    { align: 'right' }
                );
            }
            return doc.output('blob');
        }

        document.getElementById('downloadPdf').addEventListener('click', async function() {
            const blob = await generatePdfBlob();
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${state.fileName}_info.pdf`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });

        // --- CSV Export from user's code ---
        function getCsvContent() {
            let csv = `"Field","Value"\n`;
            csv += `"Name","${state.file ? state.file.name : state.fileName}"\n`;
            csv += `"Size","${state.file ? state.file.size + ' bytes' : 'N/A'}"\n`;
            csv += `"Type","${state.file ? state.file.type : 'N/A'}"\n`;
            csv += `"MD5","${state.md5}"\n`;
            Object.entries(state.exif).forEach(([key, value]) => {
                csv += `"${key}","${typeof value === 'object' ? JSON.stringify(value) : value}"\n`;
            });
            return csv;
        }
        document.getElementById('downloadCsv').addEventListener('click', function() {
            const blob = new Blob([getCsvContent()], { type: "text/csv" });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${state.fileName}_info.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });

        // --- TXT Export from user's code ---
        function getTxtContent() {
            return `${state.fileInfo}\n\nMD5 Hash: ${state.md5}\n\nEXIF Data:\n${JSON.stringify(state.exif, null, 2)}`;
        }
        document.getElementById('downloadTxt').addEventListener('click', function() {
            const blob = new Blob([getTxtContent()], { type: "text/plain" });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${state.fileName}_info.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });

        // --- JSON Export from user's code ---
        function getJsonContent() {
            return JSON.stringify({
                fileInfo: state.fileInfo,
                md5: state.md5,
                exif: state.exif
            }, null, 2);
        }
        document.getElementById('downloadJson').addEventListener('click', function() {
            const blob = new Blob([getJsonContent()], { type: "application/json" });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${state.fileName}_info.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });

        // --- ZIP Export from user's code ---
        document.getElementById('downloadZip').addEventListener('click', async function() {
            const zip = new JSZip();
            zip.file(`${state.fileName}_info.csv`, getCsvContent());
            zip.file(`${state.fileName}_info.txt`, getTxtContent());
            zip.file(`${state.fileName}_info.json`, getJsonContent());
            const pdfBlob = await generatePdfBlob();
            zip.file(`${state.fileName}_info.pdf`, pdfBlob);
            zip.generateAsync({ type: "blob" }).then(function(content) {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(content);
                a.download = `${state.fileName}_info.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            });
        });

        // Add a global error handler to make sure the app doesn't break
        window.addEventListener('unhandledrejection', event => {
            console.error('An unhandled promise rejection occurred:', event.reason);
        });
    </script>
</body>
</html>
